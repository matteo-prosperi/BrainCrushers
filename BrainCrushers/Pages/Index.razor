@page "/"
@page "/{chapter}"

@using Markdig
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis.Emit
@using Microsoft.CodeAnalysis.Text
@using System.Text.RegularExpressions
@using System.Runtime.Loader
@using System.Text

<PageTitle>@Title</PageTitle>

@if(ErrorText is not null)
{
	@ErrorText
}
else
{
	@foreach (var element in MarkDown!.Sections)
	{
		if (element is ChapterMarkdown.Html htmlElement)
		{
			<div class="container-fluid">
				@((MarkupString)htmlElement.Value)
			</div>
		}
		else if (element is ChapterMarkdown.CodeRegion codeElement)
		{
			<div class="container-fluid" style="height:@(codeElement.LineCount * 19 + 5)px;background-color:@(codeElement.IsReadonly ? "lightgrey":"lightblue")">
				<MonacoEditor ConstructionOptions="@((editor) => EditorConstructionOptions(editor, codeElement))" OnDidChangeModelContent="@((e) => EditorOnDidChangeModelContent(e, codeElement))" />
			</div>
		}
		else if (element is ChapterMarkdown.RunCommand runElement)
		{
			<div class="container-fluid">
				<button class="btn btn-primary" @onclick="@(() => RunAsync(runElement))" disabled="@IsBuildDisabled">Build and run</button>
			</div>
			<div class="container-fluid" style="height:@(runElement.LineCount * 19 + 5)px;background-color:@(runElement.Success switch { true => "lightgreen", false => "pink", _ => "white"})">
				<MonacoEditor ConstructionOptions="@((editor) => OutputConstructionOptions(editor, runElement))" />
				<!--<textarea class="form-control" readonly>@runElement.Result</textarea>-->
			</div>
		}
	}
}

@code{
	[Parameter]
	public string? Chapter { get; set; }

	[Inject]
	public HttpClient Client { get; set; }

	[Inject]
	public NavigationManager NavigationManager { get; set; }

	public string? ErrorText { get; private set; } = "Loading...";

	public string? Title { get; private set; } = "Loading...";

	public ChapterMarkdown? MarkDown;

	public bool IsBuildDisabled { get; private set; } = false;

	public Task<string> TestingCode;

	protected override async Task OnInitializedAsync()
	{
		NavigationManager.LocationChanged += HandleLocationChanged;

		if (Chapter is null)
		{
			Chapter = "index";
		}

		var markdownTask = Client.GetStringAsync($"chapters/{Uri.EscapeDataString(Chapter)}/index.md");
		var codeTask = Client.GetStringAsync($"chapters/{Uri.EscapeDataString(Chapter)}/code.cs");
		TestingCode = Client.GetStringAsync($"chapters/{Uri.EscapeDataString(Chapter)}/testing.cs");

		var markdown = await markdownTask;
		CodeFile? codeFile = null;
		try
		{
			var code = await codeTask;
			codeFile = new(code);
		}
		catch
		{
		}

		MarkDown = new ChapterMarkdown(markdown, codeFile);

		ErrorText = null;
		Title = Chapter;
	}

	private async void RunAsync(ChapterMarkdown.RunCommand command)
	{
		IsBuildDisabled = true;
		await command.SetResultAsync(String.Empty, success: null);

		StringBuilder code = new();
		foreach(var region in MarkDown!.Code.Regions)
		{
			if (region.Editor is null)
			{
				code.Append(region.Code);
				code.Append(Environment.NewLine);
			}
			else
			{
				code.Append(await region.Editor.GetValue());
				code.Append(Environment.NewLine);
			}
		}

		var compiler = new Compiler(Client);
		var (compilationResult, collectibleType) = await compiler.CompileAsync(new string[] { code.ToString(), await TestingCode }, command.TypeName);
		try
		{
			if (!compilationResult.Success)
			{
				StringBuilder sb = new();
				sb.AppendLine();
				sb.AppendLine("Diagnostics:");
				foreach (var d in compilationResult.Diagnostics)
				{
					sb.AppendLine();
					sb.AppendLine(d.ToString());
				}
				await command.SetResultAsync(sb.ToString(), success: false);
				return;
			}

			if (collectibleType?.Type is not null)
			{
				object chapterComponent = Activator.CreateInstance(collectibleType.Type)!;
				try
				{
					var runAsync = collectibleType.Type.GetMethod("TestAsync")!;
					await foreach (string s in (IAsyncEnumerable<string>)runAsync.Invoke(chapterComponent, parameters: null)!)
					{
						await command.SetResultAsync(command.Result + s, success: null);
						StateHasChanged();
					}
				}
				catch (ApplicationException e)
				{
					await command.SetResultAsync(command.Result + Environment.NewLine + e.Message + (e.InnerException is null ? "" : Environment.NewLine + e.InnerException), success: false);
					return;
				}

				await command.SetResultAsync(null, success: true);
			}
		}
		finally
		{
			collectibleType?.Dispose();
			IsBuildDisabled = false;
			StateHasChanged();
		}
	}

	private StandaloneEditorConstructionOptions EditorConstructionOptions(MonacoEditor editor, ChapterMarkdown.CodeRegion region)
	{
		region.Region.Editor = editor;

		return new StandaloneEditorConstructionOptions
		{
			AutomaticLayout = true,
			Language = "csharp",
			Value = region.Region.Code,
			ReadOnly = region.IsReadonly,
			LineNumbers = "off",
			ScrollBeyondLastLine = false,
			RenderLineHighlight = "none",
			Minimap = new() { Enabled = false },
			Folding = false
		};
	}

	private StandaloneEditorConstructionOptions OutputConstructionOptions(MonacoEditor editor, ChapterMarkdown.RunCommand runCommand)
	{
		runCommand.Editor = editor;

		return new StandaloneEditorConstructionOptions
		{
			AutomaticLayout = true,
			Language = "text/plain",
			ReadOnly = true,
			LineNumbers = "off",
			ScrollBeyondLastLine = false,
			RenderLineHighlight = "none",
			Minimap = new() { Enabled = false },
			Folding = false
		};
	}

	private void EditorOnDidChangeModelContent(ModelContentChangedEvent modelContentChangedEvent, ChapterMarkdown.CodeRegion codeElement)
	{
		foreach(var change in modelContentChangedEvent.Changes)
		{
			codeElement.LineCount += change.Range.StartLineNumber - change.Range.EndLineNumber + change.Text.Where(c => c == '\n').Count();
		}
	}

	private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
	{
		// TODO Handle navigation
	}

    public void Dispose()
    {
        NavigationManager.LocationChanged -= HandleLocationChanged;
    }
}